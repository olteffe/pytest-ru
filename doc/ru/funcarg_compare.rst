:orphan:

.. _`funcargcompare`:

pytest-2.3: обоснование эволюции фикстур/функций funcarg
=============================================================

**Целевая аудитория**: Чтение этого документа требует базовых знаний в области
тестирования на python, методов настройки xUnit и (предыдущего) базового механизма pytest
funcarg, см. https://docs.pytest.org/en/stable/historical-notes.html#funcargs-and-pytest-funcarg.
Если вы новичок в pytest, вы можете просто проигнорировать этот раздел и прочитать другие разделы.

.. currentmodule:: _pytest

Недостатки предыдущего механизма ``pytest_funcarg__``
--------------------------------------------------------------

Механизм funcarg в pytest-2.3 вызывает фабрику каждый раз, когда требуется
funcarg для тестовой функции.  Если фабрика хочет
повторно использовать ресурс в разных диапазонах, она часто использовала
помощник ``request.cached_setup()`` для управления кэшированием
ресурсов.  Вот базовый пример того, как можно реализовать
объект базы данных для каждой сессии:

.. code-block:: python

    # листинг conftest.py
    class Database:
        def __init__(self):
            print("database instance created")

        def destroy(self):
            print("database instance destroyed")


    def pytest_funcarg__db(request):
        return request.cached_setup(
            setup=DataBase, teardown=lambda db: db.destroy, scope="session"
        )

У этого подхода есть несколько ограничений и трудностей:

1. Создание ресурсов funcarg  является не простым делом, вместо этого необходимо
   понять сложную механику метода cached_setup().

2. Параметризация ресурса "db" не является простой задачей:
   вам нужно применить декоратор "parametrize" или реализовать
   :py:func:`~hookspec.pytest_generate_tests` хук
   вызывающий :py:func:`~pytest.Metafunc.parametrize`, который
   выполняет параметризацию в тех местах, где ресурс
   используется.  Более того, вам необходимо модифицировать фабрику, чтобы использовать
   ``extrakey`` параметр, содержащий ``request.param`` для
   вызова ``Request.cached_setup``.

3. Несколько параметризованных ресурсов, привязанных к сеансу, будут активны
   в одно и то же время, что затрудняет их влияние на глобальное состояние
   тестируемого приложения.

4. Нет никакого способа использовать фабрики funcarg
   в методах настройки xUnit.

5. Непараметризованная функция фикстуры не может использовать параметризованный
   funcarg ресурс, если это не указано в сигнатуре тестовой функции.

Все эти ограничения устранены в pytest-2.3 и улучшены в :ref:`fixture mechanism <fixture>`.


Прямое масштабирование фабрик фикстур/funcarg
--------------------------------------------------------

Вместо вызова cached_setup() с областью действия кэша можно использовать декоратор
:ref:`@pytest.fixture <pytest.fixture>` и непосредственно указать
область видимости:

.. code-block:: python

    @pytest.fixture(scope="session")
    def db(request):
        # фабрика будет вызываться только один раз за сеанс -
        db = DataBase()
        request.addfinalizer(db.destroy)  # уничтожается по окончании сеанса
        return db

Для этой реализации фабрики больше не нужно вызывать ``cached_setup()``.
поскольку она будет вызываться только один раз за сессию.  Более того, функция
``request.addfinalizer()`` регистрирует финализатор в соответствии с указанной
областью видимости ресурса, на котором работает фабричная функция.


Прямая параметризация фабрик ресурсов funcarg
----------------------------------------------------------

Ранее фабрики funcarg не могли напрямую вызывать параметризацию.
Вам нужно было указать декоратор ``@parametrize`` на вашей тестовой функции
или реализовать хук ``pytest_generate_tests``, чтобы выполнить
параметризацию, т.е. вызов теста несколько раз с разными значениями.
В pytest-2.3 появился декоратор для использования на самой фабрике:

.. code-block:: python

    @pytest.fixture(params=["mysql", "pg"])
    def db(request):
        ...  # использование request.param

Здесь фабрика будет вызвана дважды (с соответствующими значениями "mysql"
и "pg", установленными в качестве атрибутов ``request.param``) и все
тесты, требующие "db", будут выполняться дважды.  Значения "mysql" и
"pg" также будут использоваться для отчетов о вариантах вызова тестов.

Этот новый способ параметризации фабрик funcarg должен во многих случаях
позволит повторно использовать уже написанные фабрики, поскольку
``request.param`` уже эффективно использовался, когда тестовые функции/классы
параметризовались через
:py:func:`metafunc.parametrize(indirect=True) <pytest.Metafunc.parametrize>` вызовы.

Конечно, совершенно нормально сочетать параметризацию и scope:

.. code-block:: python

    @pytest.fixture(scope="session", params=["mysql", "pg"])
    def db(request):
        if request.param == "mysql":
            db = MySQL()
        elif request.param == "pg":
            db = PG()
        request.addfinalizer(db.destroy)  # уничтожается по окончании сеанса
        return db

Это приведет к выполнению всех тестов, требующих ресурса «db» для каждого сеанса дважды,
получая значения, созданные двумя соответствующими вызовами фабричной функции.


Нет префикса ``pytest_funcarg__`` при использовании декоратора @fixture
------------------------------------------------------------------------

При использовании декоратора ``@fixture`` имя функции
обозначает имя, под которым ресурс может быть доступен как аргумент функции:

.. code-block:: python

    @pytest.fixture()
    def db(request):
        ...

Имя, под которым может быть запрошен ресурс funcarg - это ``db``.

Вы по-прежнему можете использовать "старый" бездекораторный способ указания фабрик funcarg, например:

.. code-block:: python

    def pytest_funcarg__db(request):
        ...


Но тогда невозможно определить scope и параметризацию. Поэтому рекомендуется использовать
фабричный декоратор.


Решение проблем, связанных с setup/autouse фикстурами
--------------------------------------------------------------

pytest долгое время предлагал хуки pytest_configure и pytest_sessionstart,
которые часто используются для настройки глобальных ресурсов. У этого решения есть
несколько проблем:

1. При распределенном тестировании управляющий процесс будет настраивать тестовые ресурсы,
   которые никогда не нужны, потому что он только координирует выполнение теста
   деятельности рабочих процессов.

2. Если вы выполняете только сбор (с параметром "--collect-only")
   resource-setup все равно будет выполнен.

3. Если pytest_sessionstart содержится в некоторых подкаталогах
   файла conftest.py, он не будет вызван. Это связано с тем,
   что этот хук фактически используется для создания отчетов, в частности, заголовок
   теста с пользовательской информацией платформы.

Более того, было нелегко определить масштабируемую настройку из плагинов или
conftest файлов, кроме как реализовать хук ``pytest_runtest_setup()`` и заботиться о скопировании/кэшировании самостоятельно.
и самостоятельно заботиться о обзоре/кэшировании. И практически невозможно
сделать это с помощью параметризации, поскольку ``pytest_runtest_setup()`` вызывается
во время выполнения теста, а параметризация происходит во время сбора.

Из этого следует, что pytest_configure/session/runtest_setup часто не
подходят для реализации общих потребностей в фикстурах.  Поэтому,
pytest-2.3 вводит :ref:`autouse fixtures`, которые полностью
интегрируются с общим механизмом :ref:`fixture <fixture>`
и устаревают многие предыдущие варианты использования хуков pytest.

Обнаружение фикстур/funcargs теперь происходит во время сбора
---------------------------------------------------------------------

Начиная с pytest-2.3, обнаружение фабрик фикстур/funcarg осуществляется
во время сбора.  Это более эффективно, особенно для больших тестовых наборов.
Более того, вызов команды "pytest --collect-only" в будущем сможет
показывать много информации о настройках и, таким образом, это хороший способ получить
общее представление об управлении фикстурами в вашем проекте.

.. _`compatibility notes`:

.. _`funcargscompat`:

Заключение и примечания по совместимости
---------------------------------------------------------

**funcargs** были первоначально введены в pytest-2.0.  В pytest-2.3
механизм был расширен и доработан и теперь описывается как
фикстуры:

* Ранее фабрики funcarg указывались со специальным префиксом
  ``pytest_funcarg__NAME`` вместо использования декоратора
  ``@pytest.fixture``.

* Фабрики получали объект ``request``, который управлял кэшированием через
  ``request.cached_setup()`` вызовы и позволял использовать другие funcargs через
  ``request.getfuncargvalue()`` вызовы. Эти запутанные API усложняли
  правильную параметризацию и реализацию кэширования ресурсов.
  Новый декоратор :py:func:`pytest.fixture` позволяет объявить область применения
  и позволить pytest сделать все за вас.

* Если вы использовали фабрики parametrization и funcarg, которые использовали
  ``request.cached_setup()``, рекомендуется потратить несколько минут
  и упростить код вашей фикстуры, чтобы использовать :ref:`@pytest.fixture`
  вместо этого декоратора.  Это также позволит воспользоваться преимуществами
  автоматической группировкой тестов по ресурсам.
