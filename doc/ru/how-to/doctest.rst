.. _doctest:

Как запустить доктесты(doctests)
=========================================================

По умолчанию все файлы, соответствующие шаблону ``test*.txt``, будут запускаться через
стандартный модуль Python ``doctest``. Вы можете изменить шаблон, выполнив:

.. code-block:: bash

    pytest --doctest-glob="*.rst"

в командной строке. ``--doctest-glob`` можно указать несколько раз в командной строке.

Если у вас есть такой текстовый файл:

.. code-block:: text

    # листинг test_example.txt

    hello this is a doctest
    >>> x = 3
    >>> x
    3

тогда вы можете просто вызвать ``pytest`` напрямую:

.. code-block:: pytest

    $ pytest
    =========================== test session starts ============================
    platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-0.x.y
    cachedir: $PYTHON_PREFIX/.pytest_cache
    rootdir: $REGENDOC_TMPDIR
    collected 1 item

    test_example.txt .                                                   [100%]

    ============================ 1 passed in 0.12s =============================

По умолчанию pytest будет собирать файлы ``test*.txt`` в поисках директив doctest, но вы
можете передать дополнительные глобальные параметры, используя параметр ``--doctest-glob``
(разрешено несколько).

Помимо текстовых файлов, вы также можете выполнять тесты прямо из строк документации
ваших классов и функций, в том числе из тестовых модулей:

.. code-block:: python

    # листинг mymodule.py
    def something():
        """a doctest in a docstring
        >>> something()
        42
        """
        return 42

.. code-block:: bash

    $ pytest --doctest-modules
    =========================== test session starts ============================
    platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-0.x.y
    cachedir: $PYTHON_PREFIX/.pytest_cache
    rootdir: $REGENDOC_TMPDIR
    collected 2 items

    mymodule.py .                                                        [ 50%]
    test_example.txt .                                                   [100%]

    ============================ 2 passed in 0.12s =============================

Вы можете сделать эти изменения постоянными в своем проекте, поместив их в файл
pytest.ini следующим образом:

.. code-block:: ini

    # content of pytest.ini
    [pytest]
    addopts = --doctest-modules


Кодировки
------------

Кодировка по умолчанию - **UTF-8**, но вы можете указать кодировку, которая будет
использоваться для этих файлов doctest, используя ini-параметр ``doctest_encoding``:

.. code-block:: ini

    # листинг pytest.ini
    [pytest]
    doctest_encoding = latin1

Использование опции 'doctest'
-------------------------------

Стандартный модуль Python ``doctest`` предоставляет некоторые опции `options <https://docs.python.org/3/library/doctest.html#option-flags>`__
для настройки строгости тестов doctest. В pytest вы можете включить эти флаги с помощью файла конфигурации.

Например, чтобы заставить pytest игнорировать конечные пробелы и игнорировать длинные трассировки
стека исключений, вы можете просто написать:

.. code-block:: ini

    [pytest]
    doctest_optionflags = NORMALIZE_WHITESPACE IGNORE_EXCEPTION_DETAIL

Кроме того, параметры можно включить с помощью встроенного комментария в самом тесте документа:

.. code-block:: rst

    >>> something_that_raises()  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError: ...

pytest также вводит новые опции:

* ``ALLOW_UNICODE``: при включении префикс ``u`` удаляется из строк unicode в ожидаемом выводе
  doctest. Это позволяет запускать доктесты в Python 2 и Python 3 без изменений.

* ``ALLOW_BYTES``: аналогично, префикс ``b`` удаляется из байтовых строк
  в ожидаемом выводе doctest.

* ``NUMBER``: при включении, числа с плавающей точкой должны совпадать только с
  точностью, указанной в ожидаемом выводе doctest. Например,
  следующий вывод должен соответствовать только 2 десятичным знакам::

      >>> math.pi
      3.14

  Если вы записали ``3.1416``, то актуальный вывод будет соответствовать 4 десятичным
  разрядам; и так далее.

  Это позволяет избежать ложных срабатываний, вызванных ограниченной точностью с плавающей точкой,
  например::

      Expected:
          0.233
      Got:
          0.23300000000000001

  ``NUMBER`` также поддерживает списки чисел с плавающей точкой - фактически, он
  соответствует числам с плавающей точкой, появляющимся в любом месте вывода, даже внутри строки!
  Это означает, что может быть нецелесообразно включать глобально в ``doctest_optionflags`` в вашем
  файле конфигурации.

  .. versionadded:: 5.1


Продолжение при падении
------------------------

По умолчанию pytest сообщает только о первом сбое для данного doctest. Если
вы хотите продолжить тест даже при падениях, сделайте:

.. code-block:: bash

    pytest --doctest-modules --doctest-continue-on-failure


Выходной формат
----------------

Вы можете изменить выходной формат diff в случае падения ваших тестов,
используя один из стандартных форматов модулей doctest в опциях
(см. :data:`python:doctest.REPORT_UDIFF`, :data:`python:doctest.REPORT_CDIFF`,
:data:`python:doctest.REPORT_NDIFF`, :data:`python:doctest.REPORT_ONLY_FIRST_FAILURE`):

.. code-block:: bash

    pytest --doctest-modules --doctest-report none
    pytest --doctest-modules --doctest-report udiff
    pytest --doctest-modules --doctest-report cdiff
    pytest --doctest-modules --doctest-report ndiff
    pytest --doctest-modules --doctest-report only_first_failure


Особенности pytest
------------------------

Некоторые функции упрощают написание тестов или обеспечивают лучшую интеграцию с
вашим существующим набором тестов. Однако имейте ввиду, что используя эти функции, вы сделаете
ваши doctests несовместимы со стандартным модулем ``doctests``.

Использование фикстур
^^^^^^^^^^^^^^^^^^^^^^^

Можно использовать фикстуры с помощью помощника ``getfixture``:

.. code-block:: text

    # листинг example.rst
    >>> tmp = getfixture('tmp_path')
    >>> ...
    >>>

Обратите внимание, что фикстура должна быть определена в месте, видимом pytest, например, в файле
или плагине `conftest.py`; обычные файлы Python, содержащие строки документации, обычно не сканируются
на наличие фикстур, если явно не настроено в :confval:`python_files`.

Также, метка :ref:`usefixtures <usefixtures>` и маркированная фикстура :ref:`autouse <autouse>`
поддерживаются при выполнении текстовых тестовых файлов


.. _`doctest_namespace`:

Фикстура 'doctest_namespace'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Фикстура ``doctest_namespace`` может использоваться для вставки элементов в
пространство имен, в котором запускаются ваши тесты. Она предназначена для использования в
ваших собственных фикстурах, чтобы предоставить тесты, которые используют их с контекстом.

``doctest_namespace`` - это стандартный объект ``dict``, в который вы
поместите объекты, которые вы хотите отобразить, в пространство имен doctest:

.. code-block:: python

    # листинг conftest.py
    import numpy


    @pytest.fixture(autouse=True)
    def add_np(doctest_namespace):
        doctest_namespace["np"] = numpy

которые затем можно будет напрямую использовать в ваших тестах:

.. code-block:: python

    # листинг numpy.py
    def arange():
        """
        >>> a = np.arange(10)
        >>> len(a)
        10
        """
        pass

Обратите внимание, что как и в случае с обычным файлом ``conftest.py``, фикстуры обнаруживаются в
дереве каталогов, в котором находится conftest. Это означает, что если вы поместите свой doctest с
исходным кодом, соответствующий файл conftest.py должен находиться в том же дереве каталогов.
Фикстуры не будут обнаружены в дереве соседних каталогов!

Пропуск тестов
^^^^^^^^^^^^^^^^

По тем же причинам, по которым можно пропустить обычные тесты, также можно пропустить тесты внутри doctests.

Чтобы пропустить единственную проверку внутри доктеста, вы можете использовать стандартную директиву
`doctest.SKIP <https://docs.python.org/3/library/doctest.html#doctest.SKIP>`__:

.. code-block:: python

    def test_random(y):
        """
        >>> random.random()  # doctest: +SKIP
        0.156231223

        >>> 1 + 1
        2
        """

Это пропустит первую проверку, но не вторую".

pytest также разрешает использование стандартных функций pytest :func:`pytest.skip` и
:func:`pytest.xfail` внутри доктест, что может быть полезно, потому что вы можете
затем пропустить/xfail на основе внешних условий:


.. code-block:: text

    >>> import sys, pytest
    >>> if sys.platform.startswith('win'):
    ...     pytest.skip('this doctest does not work on Windows')
    ...
    >>> import fcntl
    >>> ...

Однако использование этих функций не рекомендуется, поскольку это снижает удобочитаемость
строк документации.

.. note::

    :func:`pytest.skip` и :func:`pytest.xfail` вести себя по-разному в зависимости от того, находятся
    ли тесты в файле Python (в строках документации) или в текстовом файле, содержащем тесты, смешанные
    с текстом:

    * Модули Python(docstrings): функции действуют только в этой конкретной строке документации,
      позволяя другим строкам документации в том же модуле выполняться как обычно.

    * Текстовые файлы: функции будут skip/xfail проверки для остальной части всего файла.



Альтернативы
-------------

Хотя встроенная поддержка pytest предоставляет хороший набор функций для использования
doctests, если вы их широко используете, вас могут заинтересовать эти внешние пакеты
которые добавляют много дополнительных функций и включают интеграцию с pytest:

* `pytest-doctestplus <https://github.com/astropy/pytest-doctestplus>`__: обеспечивает расширенную
  поддержку doctest и позволяет тестировать файлы reStructuredText (".rst").

* `Sybil <https://sybil.readthedocs.io>`__: предоставляет способ тестовых примеров в вашей
  документации, анализируя их из источника документации и оценивая проанализированные примеры как часть
  вашего обычного тестового запуска.
