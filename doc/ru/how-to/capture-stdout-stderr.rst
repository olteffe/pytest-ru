
.. _`captures`:

Захват потоков вывода stdout/stderr
=========================================================

Поведение при захвате потоков stdout/stderr/stdin по умолчанию
-------------------------------------------------------------

Во время выполнения теста любой вывод, отправленный на ``stdout`` и ``stderr``, фиксируется.
Если тест или метод настройки падает, его соответствующие захваченные выходные
данные обычно отображаются вместе с трассировкой ошибок(это поведение можно настроить
с помощью параметра командной строки ``--show-capture``).

Кроме того, для ``stdin`` устанавливается нулевой объект, который не удастся прочитать из него, потому
что при запуске автоматизированных тестов редко требуется ждать интерактивного ввода.

По умолчанию захват осуществляется путем перехвата записи в файловые дескрипторы низкого уровня.
Это позволяет захватывать вывод простых операторов печати, а также вывод подпроцесса, запущенного тестом.

.. _capture-method:

Установка методов захвата или отключение захвата
-------------------------------------------------

Есть три способа, которыми ``pytest`` может выполнять захват:

* ``fd`` захват уровня файлового дескриптора/file descriptor(по умолчанию): Все записи, поступающие
  в файловые дескрипторы 1 и 2 операционной системы, будут захвачены.

* ``sys`` - системный уровневый захват: записываются только в файлы Python ``sys.stdout``
  и ``sys.stderr``. Захват записей в файловые дескрипторы не производится.

* ``tee-sys`` захват: записываемые Python-ом в ``sys.stdout`` и ``sys.stderr``
  будут захвачены, однако записи также будут проходить к фактическому ``sys.stdout`` и
  ``sys.stderr``. Это позволяет выводить на печать в реальном времени и захватывать для использования
  плагинами, такими как ``junitxml``(новое в ``pytest`` версии 5.4).

.. _`disable capturing`:

Можно влиять на механизмы захвата вывода из командной строки:

.. code-block:: bash

    pytest -s                  # отключить весь захват
    pytest --capture=sys       # заменять sys.stdout/stderr файлами в памяти
    pytest --capture=fd        # указывает файловые дескрипторы 1 и 2 на временный файл
    pytest --capture=tee-sys   # сочетание 'sys' и '-s', захватывать sys.stdout/stderr
                               # и передать его фактическому sys.stdout/stderr

.. _printdebugging:

Использование операторов печати для отладки
---------------------------------------------------

Одним из основных преимуществ захвата вывода stdout/stderr по умолчанию является то, что вы
можете использовать операторы печати для отладки:

.. code-block:: python

    # листинг test_module.py


    def setup_function(function):
        print("setting up", function)


    def test_func1():
        assert True


    def test_func2():
        assert False

и запуск этого модуля покажет вам точный вывод неисправной функции и скроет другой:

.. code-block:: pytest

    $ pytest
    =========================== test session starts ============================
    platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-0.x.y
    cachedir: $PYTHON_PREFIX/.pytest_cache
    rootdir: $REGENDOC_TMPDIR
    collected 2 items

    test_module.py .F                                                    [100%]

    ================================= FAILURES =================================
    ________________________________ test_func2 ________________________________

        def test_func2():
    >       assert False
    E       assert False

    test_module.py:12: AssertionError
    -------------------------- Captured stdout setup ---------------------------
    setting up <function test_func2 at 0xdeadbeef>
    ========================= short test summary info ==========================
    FAILED test_module.py::test_func2 - assert False
    ======================= 1 failed, 1 passed in 0.12s ========================

Доступ к записанным выводам из тестовой функции
---------------------------------------------------

Фикстуры``capsys``, ``capsysbinary``, ``capfd``, и ``capfdbinary``
разрешают доступ к выходным данным stdout/stderr, созданным во время выполнения теста.
Вот пример тестовой функции, которая выполняет некоторые проверки, связанные с выводом:

.. code-block:: python

    def test_myoutput(capsys):  # или используйте "capfd" для уровня fd
        print("hello")
        sys.stderr.write("world\n")
        captured = capsys.readouterr()
        assert captured.out == "hello\n"
        assert captured.err == "world\n"
        print("next")
        captured = capsys.readouterr()
        assert captured.out == "next\n"

Вызов ``readouterr()`` делает моментальные снимки вывода на данный момент - и захват будет продолжен.
После завершения функции тестирования исходные потоки будут восстановлены. Использование ``capsys``
таким образом освобождает ваш тест от необходимости заботиться о настройке сброса выходных потоков,
а также хорошо взаимодействует с собственным захватом для каждого теста pytest.

Если вы хотите выполнить захват на уровне дескриптора файла, вы можете использовать фикстуру
``capfd``, которая предлагает точно такой же интерфейс, но позволяет также захватывать выходные данные
из библиотек или подпроцессов, которые напрямую записываются в выходные потоки уровня операционной
системы (FD1 и FD2).

Возвращаемое значение ``readouterr`` изменилось на ``namedtuple`` с двумя атрибутами: ``out`` и ``err``.

Если тестируемый код записывает нетекстовые данные, вы можете зафиксировать это с помощью фикстуры
``capfdbinary``, которая вместо этого возвращает ``bytes`` из метода ``readouterr``.
Фикстура ``capfdbinary`` работает на уровне файлового дескриптора.

Чтобы временно отключить захват в рамках теста, у ``capsys`` и ``capfd`` есть метод ``disabled()``, который
можно использовать в качестве контекстного менеджера, отключая захват внутри блока ``with``:

.. code-block:: python

    def test_disabling_capturing(capsys):
        print("this output is captured")
        with capsys.disabled():
            print("output not captured, going directly to sys.stdout")
        print("this output is also captured")
