.. _`writinghooks`:

Написание хук-функций
======================


.. _validation:

Проверка и выполнение хук-функций
--------------------------------------

pytest вызывает хук-функции из зарегистрированных плагинов для любой заданной спецификации хука.
Давайте посмотрим на типичную хук-функцию ``pytest_collection_modifyitems(session, config,
items)``, которую pytest вызывает после завершения сбора всех тестовых элементов.

Когда мы реализуем функцию ``pytest_collection_modifyitems`` в нашем плагине, pytest во время
регистрации будет проверять, что вы используете имена аргументов, которые соответствуют спецификации,
и выйдет из строя, если нет.

Let's look at a possible implementation:

.. code-block:: python

    def pytest_collection_modifyitems(config, items):
        # вызывается после завершения сборки
        # вы можете изменить список ``items``
        ...

Здесь, ``pytest`` передает в ``config`` (объект конфигурации pytest) и ``items`` (список собранных
тестовых заданий), но не будет передавать аргумент ``session``, потому что мы не указали его в сигнатуре
функции. Это динамическое «сокращение» аргументов позволяет ``pytest`` быть «совместимым с будущим»:
мы можем ввести новые именованные параметры хука, не нарушая сигнатуры существующих реализаций хуков.
Это одна из причин общей долгой совместимости плагинов pytest.

Обратите внимание, что хук-функциям, отличным от ``pytest_runtest_*``, не разрешено вызывать
исключения. Это нарушит запуск pytest.



.. _firstresult:

firstresult: остановиться при первом отличном от None результате
-------------------------------------------------------------------

Большинство вызовов хуков ``pytest`` приводят к **списку результатов**, который содержит все отличные
от None результаты вызываемых хук-функций.

В некоторых спецификациях хуков используется опция ``firstresult=True``, так что вызов хука
выполняется только до тех пор, пока первая из N зарегистрированных функций не вернет результат,
отличный от None, который затем принимается как результат общего вызова хука. Остальные хук-функции
в этом случае не вызываются.

.. _`hookwrapper`:

hookwrapper: выполнение вокруг других хуков
-------------------------------------------------

.. currentmodule:: _pytest.core



Плагины pytest могут реализовывать обертки(wrappers) хуков, которые обертывают выполнение других реализаций хуков.
Обертка хуков - это функция-генератор, которая возвращает ровно один раз. Когда pytest вызывает хуки,
он сначала выполняет обертки хуков и передает те же аргументы, что и обычные хуки.

В точке yield обертки хука pytest выполнит следующие реализации хука и вернет
их результат в точку yield в виде экземпляра :py:class:`Result <pluggy._Result>`, который
инкапсулирует информацию о результате или исключении. Таким образом, сама точка yield обычно не вызывает
исключений (если нет ошибок).

Вот пример определения обертки хука:

.. code-block:: python

    import pytest


    @pytest.hookimpl(hookwrapper=True)
    def pytest_pyfunc_call(pyfuncitem):
        do_something_before_next_hook_executes()

        outcome = yield
        # outcome.excinfo может быть None или (cls, val, tb) кортеж

        res = outcome.get_result()  # будет вызван, если результатом было исключение

        post_process_result(res)

        outcome.force_result(new_res)  # чтобы переопределить возвращаемое значение в систему плагинов

Обратите внимание, что обертки хуков сами по себе не возвращают результаты, они просто выполняют
трассировку или другие побочные эффекты вокруг фактических реализаций хуков. Если результатом базового
хука является изменяемый объект, они могут изменить этот результат, но, вероятно, лучше этого избегать.

Для получения дополнительной информации обратитесь к
:ref:`pluggy documentation about hookwrappers <pluggy:hookwrappers>`.

.. _plugin-hookorder:

Пример упорядочивания/вызова хук-функции
-------------------------------------------------

Для любой данной спецификации хука может быть более одной реализации, и поэтому мы обычно
рассматриваем выполнение ``хука`` как вызов функции ``1:N``, где ``N`` - количество зарегистрированных функций.
Есть способы повлиять на то, идет ли реализация хука до или после других, то есть на позицию в списке
функций размером ``N``:

.. code-block:: python

    # Плагин 1
    @pytest.hookimpl(tryfirst=True)
    def pytest_collection_modifyitems(items):
        # выполнится как можно раньше
        ...


    # Плагин 2
    @pytest.hookimpl(trylast=True)
    def pytest_collection_modifyitems(items):
        # выполнится как можно позже
        ...


    # Плагин 3
    @pytest.hookimpl(hookwrapper=True)
    def pytest_collection_modifyitems(items):
        # будет выполняться даже до того, как tryfirst выше!
        outcome = yield
        # будет выполняться после выполнения всех не hookwrapper

Вот порядок исполнения:

1. Pytest_collection_modifyitems Плагина 3 вызывается до точки yield, потому что это обертка хука.

2. Pytest_collection_modifyitems Плагина 1 вызывается следующим, потому что он отмечен
   ``tryfirst=True``.

3. pytest_collection_modifyitems Плагина 2 вызывается, потому что он отмечен
   ``trylast=True`` (но даже без этой отметки это будет после Плагина 1).

4. pytest_collection_modifyitems Плагина 3 затем выполнение кода после точки yield.
   Yield получает :py:class:`Result <pluggy._Result>` экземпляр, который инкапсулирует
   результат вызова не-оберток. Обертки не должны изменять результат.

Можно использовать ``tryfirst`` и ``trylast`` также в сочетании с
``hookwrapper=True``, в этом случае это повлияет на порядок *оборачивания хуков* между собой.


Объявление новых хуков
------------------------

.. note::

    Это краткий обзор того, как добавлять новые хуки и как они работают в целом, но более полный
    обзор можно найти в `the pluggy documentation <https://pluggy.readthedocs.io/en/latest/>`__.

.. currentmodule:: _pytest.hookspec

Плагины и файлы ``conftest.py`` может объявлять новые хуки, которые затем могут быть реализованы
другими плагинами для изменения поведения или взаимодействия с новым плагином:

.. autofunction:: pytest_addhooks
    :noindex:

Хуки обычно объявляются как ничего не делающие функции, которые содержат только документацию,
описывающую, когда будет вызван хук и какие возвращаемые значения ожидаются. Имена функций должны
начинаться с `pytest_`, иначе pytest их не распознает.

Вот пример. Предположим, что этот код находится в модуле ``sample_hook.py``.

.. code-block:: python

    def pytest_my_hook(config):
        """
        Получаем конфигурацию pytest и выполняем с ней определенные действия
        """

Чтобы зарегистрировать хуки в pytest, они должны быть структурированы в собственном модуле или классе.
Затем этот класс или модуль можно передать в ``pluginmanager`` с помощью функции ``pytest_addhooks``.
(которая сама является хуком, выставляемым pytest).

.. code-block:: python

    def pytest_addhooks(pluginmanager):
        """ В данном примере предполагается, что крючки сгруппированы в модуле 'sample_hook'. """
        from my_app.tests import sample_hook

        pluginmanager.add_hookspecs(sample_hook)

Реальные примеры см. в `newhooks.py`_ из `xdist <https://github.com/pytest-dev/pytest-xdist>`_.

.. _`newhooks.py`: https://github.com/pytest-dev/pytest-xdist/blob/974bd566c599dc6a9ea291838c6f226197208b46/xdist/newhooks.py

Хуки могут быть вызваны из фикстуры или другого хука. В обоих случаях, хуки вызываются через объект
``hook``, доступный в объекте ``config``. Большинство хуков получают объект ``config`` напрямую,
в то время как фикстуры могут использовать фикстуру ``pytestconfig``, которая предоставляет тот же объект.

.. code-block:: python

    @pytest.fixture()
    def my_fixture(pytestconfig):
        # вызов хука с именем "pytest_my_hook"
        # 'result' будет списком возвращаемых значений из всех зарегистрированных функций.
        result = pytestconfig.hook.pytest_my_hook(config=pytestconfig)

.. note::
    Хуки получают параметры, используя только аргументы ключевых слов.

Теперь ваш хук готов к использованию. Чтобы зарегистрировать функцию в хуке, другие плагины или пользователи должны
теперь просто определить функцию ``pytest_my_hook`` с правильной сигнатурой в своем ``conftest.py``..

Пример:

.. code-block:: python

    def pytest_my_hook(config):
        """
        Вывести все активные хуки на экран.
        """
        print(config.hook)


.. _`addoptionhooks`:


Использование хуков в pytest_addoption
---------------------------------------------

Иногда необходимо изменить способ, которым опции командной строки определяются одним плагином на
основе хуков в другом плагине. Например, плагин может открывать опцию командной строки, для которой
другой плагин должен определить значение по умолчанию. pluginmanager может быть использован для
установки и использования хуков. Плагин должен определить и добавить хуки
и использовать pytest_addoption следующим образом:

.. code-block:: python

   # листинг hooks.py

   # Используем firstresult=True потому что мы хотим, чтобы только один плагин определял
   # это значение по умолчанию
   @hookspec(firstresult=True)
   def pytest_config_file_default_value():
       """ Возвращает значение по умолчанию для параметра командной строки файла config. """


   # листинг myplugin.py


   def pytest_addhooks(pluginmanager):
       """ Этот пример предполагает, что хуки сгруппированы в модуле 'hooks'. """
       from . import hook

       pluginmanager.add_hookspecs(hook)


   def pytest_addoption(parser, pluginmanager):
       default_value = pluginmanager.hook.pytest_config_file_default_value()
       parser.addoption(
           "--config-file",
           help="Config file to use, defaults to %(default)s",
           default=default_value,
       )

В файле conftest.py, использующем myplugin, хук будет просто определен следующим образом:

.. code-block:: python

    def pytest_config_file_default_value():
        return "config.yaml"


Дополнительно можно использовать хуки из сторонних плагинов
-----------------------------------------------------------

Использование новых хуков из плагинов, как объяснялось выше, может быть немного затруднительным
из-за стандартного механизма :ref:`validation mechanism <validation>`:
если вы зависите от плагина, который не установлен, валидация будет провалена и
сообщение об ошибке не будет иметь большого смысла для ваших пользователей.

Один из подходов заключается в том, чтобы отложить реализацию хуков в новый плагин вместо того, чтобы
объявлять функции хука непосредственно в модуле плагина, например:

.. code-block:: python

    # листинг myplugin.py


    class DeferPlugin:
        """Простой плагин для откладывания хук-функции pytest-xdist."""

        def pytest_testnodedown(self, node, error):
            """стандартная хук-функция xdist."""


    def pytest_configure(config):
        if config.pluginmanager.hasplugin("xdist"):
            config.pluginmanager.register(DeferPlugin())

Это имеет дополнительное преимущество, позволяя вам условно устанавливать хуки
в зависимости от того, какие плагины установлены.
