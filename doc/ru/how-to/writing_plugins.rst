.. _plugins:
.. _`writing-plugins`:

Написание плагинов
=====================

Легко реализовать локальные плагины conftest `local conftest plugins`_ для вашего проекта
или устанавливаемые через pip плагины `pip-installable plugins`_, которые можно использовать во многих проектах, в том числе в сторонних.
Пожалуйста, обратитесь к :ref:`using plugins` если вы хотите использовать только плагины, но не писать их.

Плагин содержит одну или несколько хук-функций. :ref:`Writing hooks <writinghooks>` написание хуков
объясняет основы и детали того, как вы можете написать хук-функцию самостоятельно.
``pytest`` реализует все аспекты конфигурации, сбора, запуска и отчетности, вызывая
:ref:`well specified hooks <hook-reference>` хорошо продуманные хуки из следующих плагинов:

* встроенные плагины: загружаются из внутреннего каталога ``_pytest``.

* :ref:`external plugins <extplugins>`: модули, обнаруженные через
  `setuptools entry points`_

* `conftest.py plugins`_: модули автоматически обнаруживаемые в тестовых каталогах.

В принципе, каждый вызов хука является вызовом функции Python ``1:N``, где ``N`` - количество
зарегистрированных функций реализации для данной спецификации. Все спецификации и реализации следуют
соглашению об именах префиксов ``pytest_``, что упрощает их распознавание и поиск.

.. _`pluginorder`:

Порядок обнаружения плагина при запуске инструмента
-------------------------------------------------------

``pytest`` загружает подключаемые модули при запуске следующим образом:

1. путем сканирования командной строки для опции ``-p no:name``
   и *блокирование* загрузки этого плагина (таким образом можно заблокировать даже встроенные плагины).
   Это происходит до обычного синтаксического анализа командной строки.

2. загрузка всех встроенных плагинов.

3. путем сканирования командной строки на наличие опции ``-p no:name``
   и загружает указанный плагин. Это происходит до обычного синтаксического анализа командной строки.

4. загрузкой всех плагинов, зарегистрированные через точку входа setuptools `setuptools entry points`_.

5. загрузив все плагины, указанные в :envvar:`PYTEST_PLUGINS` переменной окружения.

6. загрузив все conftest.py файлы :file:`conftest.py` как следует из вызова командной строки:

   - если тестовые пути не указаны, используется текущий каталог в качестве тестового пути
   - если существует, загружается ``conftest.py`` и ``test*/conftest.py`` относительно
     каталога первого тестового пути. После загрузки файла ``conftest.py``,
     загружаются все плагины, указанные в его переменной
     :globalvar:`pytest_plugins`, если таковые существуют.

   Обратите внимание, что pytest не ищет файлы ``conftest.py`` в более глубоко вложенных
   подкаталоги при запуске. Обычно рекомендуется сохранять файл ``conftest.py`` в корневом каталоге
   теста или проекта верхнего уровня.

7. рекурсивно загружаются все плагины, указанные в переменной
   :globalvar:`pytest_plugins` в файле ``conftest.py``.


.. _`pytest/plugin`: http://bitbucket.org/pytest-dev/pytest/src/tip/pytest/plugin/
.. _`conftest.py plugins`:
.. _`localplugin`:
.. _`local conftest plugins`:

conftest.py: локальные плагины для каждого каталога
----------------------------------------------------

Локальный плагин ``conftest.py`` содержит реализации хуков для конкретных каталогов.
Действия с обработкой сеанса и тестирования будут вызывать все хуки, определенные в файлах ``conftest.py``
ближе к корню файловой системы. Пример реализации хука ``pytest_runtest_setup``, который вызывается
для тестов в подкаталоге ``a``, но не для других каталогов::

    a/conftest.py:
        def pytest_runtest_setup(item):
            # called for running each test in 'a' directory
            print("setting up", item)

    a/test_sub.py:
        def test_sub():
            pass

    test_flat.py:
        def test_flat():
            pass

Вот как вы можете его запустить::

     pytest test_flat.py --capture=no  # will not show "setting up"
     pytest a/test_sub.py --capture=no  # will show "setting up"

.. note::
    Если существует файл ``conftest.py``, который не находится в
    каталоге пакета python (то есть содержащий ``__init__.py``), то
    "import conftest" может быть двусмысленным, потому что могут быть другие файлы
    ``conftest.py`` в вашем ``PYTHONPATH`` или ``sys.path``.
    Таким образом, для проектов хорошей практикой является размещение ``conftest.py``
    в рамках пакета или никогда ничего не импортировать из файла ``conftest.py``.

    См. также: :ref:`pythonpath`.

.. note::
    Некоторые хуки должны быть реализованы только в плагинах или файлах conftest.py, расположенных в
    корневом каталоге тестов, из-за того, как pytest обнаруживает плагины во время запуска,
    подробности см. в документации по каждому хуку.

Написание собственного плагина
-------------------------------

.. _`setuptools`: https://pypi.org/project/setuptools/

Если вы хотите написать плагин, есть много реальных примеров, из которых вы можете скопировать:

* пример плагина пользовательской коллекции: :ref:`yaml plugin`
* встроенные плагины, которые обеспечивают собственную функциональность pytest
* множество внешних плагинов :ref:`external plugins <plugin-list>`, предоставляющие дополнительные возможности

Все эти плагины реализуют хуки :ref:`hooks <hook-reference>` и/или фикстуры :ref:`fixtures <fixture>`
для расширения и добавления функциональности.

.. note::
    Обязательно ознакомьтесь с отличным проектом
    `cookiecutter-pytest-plugin <https://github.com/pytest-dev/cookiecutter-pytest-plugin>`_,
    который является шаблоном `cookiecutter template <https://github.com/audreyr/cookiecutter>`_
    для создания плагинов.

    Шаблон обеспечивает отличную отправную точку с работающим плагином, тестами, выполняемыми с помощью
    tox, всеобъемлющим файлом README, а также предварительно настроенной точкой входа.

Также рассмотрите возможность контрибьютить свой плагин в pytest-dev :ref:`contributing your plugin to pytest-dev<submitplugin>`
как только у него появятся довольные пользователи, кроме вас.


.. _`setuptools entry points`:
.. _`pip-installable plugins`:

Создание своего плагина, доступного для установки другими
------------------------------------------------------------

Если вы хотите сделать свой плагин доступным извне, вы можете определить так называемую точку входа для
вашего дистрибутива, чтобы pytest нашел ваш модуль плагина. Точки входа - это функция, предоставляемая
`setuptools`_. pytest ищет точку входа ``pytest11``, чтобы обнаружить свои плагины, и, таким образом,
вы можете сделать свой плагин доступным, определив его в своем вызове setuptools:

.. sourcecode:: python

    # пример файла ./setup.py
    from setuptools import setup

    setup(
        name="myproject",
        packages=["myproject"],
        # следующее делает плагин доступным для pytest
        entry_points={"pytest11": ["name_of_plugin = myproject.pluginmodule"]},
        # собственный классификатор PyPI для плагинов pytest
        classifiers=["Framework :: Pytest"],
    )

Если пакет установлен таким образом, ``pytest`` загрузит
``myproject.pluginmodule`` как плагин, который может определять хуки
:ref:`hooks <hook-reference>`.

.. note::

    Не забудьте включить ``Framework :: Pytest`` в ваш список
    `PyPI classifiers <https://pypi.org/classifiers/>`_,
    чтобы пользователям было проще найти ваш плагин.


.. _assertion-rewriting:

Перезапись assertion
----------------------

Одной из основных особенностей pytest является использование простых assert-ов и подробный анализ выражений
при падениях. Это обеспечивается «перезаписью assertion», который изменяет проанализированный AST перед
его компиляцией в байт-код. Это делается с помощью хука импорта :pep:`302`, который устанавливается на
ранней стадии при запуске pytest и выполняет эту перезапись при импорте модулей. Однако, поскольку мы
не хотим тестировать байт-код, отличный от того, который вы будете запускать в производственной среде,
этот хук перезаписывает только сами тестовые модули (как определено параметром конфигурации
:confval:`python_files`) и любые модули, которые являются частью плагинов. Любой другой импортированный
модуль не будет перезаписан, и произойдет нормальное поведение assert-а.

Если у вас есть вспомогательные assert-ы в других модулях, где вам может потребоваться перезапись assert для
включения, вам необходимо явно попросить pytest переписать этот модуль перед его импортом.

.. autofunction:: pytest.register_assert_rewrite
    :noindex:

Это особенно важно, когда вы пишете плагин pytest, который создается с использованием пакета.
Хук импорта обрабатывает только файлы ``conftest.py`` и любые модули, перечисленные в точке входа
``pytest11``, как плагины. В качестве примера рассмотрим следующий пакет::

   pytest_foo/__init__.py
   pytest_foo/plugin.py
   pytest_foo/helper.py

Со следующим основным содержимым ``setup.py``:

.. code-block:: python

   setup(..., entry_points={"pytest11": ["foo = pytest_foo.plugin"]}, ...)

В этом кейсе ``pytest_foo/plugin.py`` будет перезаписан. Если вспомогательный модуль также содержит
операторы assert, которые необходимо переписать, его необходимо пометить как таковые, прежде чем он
будет импортирован.
Проще всего пометить его для перезаписи внутри модуля ``__init__.py``, который всегда будет импортирован
первым при импорте модуля внутри пакета. Таким образом, ``plugin.py`` может по-прежнему
импортировать ``helper.py`` нормально.  Содержимое ``pytest_foo/__init__.py`` тогда должно выглядеть так:

.. code-block:: python

   import pytest

   pytest.register_assert_rewrite("pytest_foo.helper")


Требование/загрузка плагинов в тестовый модуль или файл conftest
--------------------------------------------------------------------

Вам могут потребоваться плагины в тестовом модуле или файле ``conftest.py`` с использованием :globalvar:`pytest_plugins`:

.. code-block:: python

    pytest_plugins = ["name1", "name2"]

Когда загружается тестовый модуль или подключаемый модуль conftest, также будут загружены указанные
подключаемые модули. Любой модуль может быть объявлен как плагин, включая внутренние модули
приложения:

.. code-block:: python

    pytest_plugins = "myapp.testsupport.myplugin"

:globalvar:`pytest_plugins` обрабатываются рекурсивно, поэтому обратите внимание, что в примере выше
если ``myapp.testsupport.myplugin`` также объявляет :globalvar:`pytest_plugins``, содержимое
переменной также будет загружено как плагины, и так далее.

.. _`requiring plugins in non-root conftests`:

.. note::
    Требование подключаемых модулей с помощью переменной :globalvar:`pytest_plugins` в некорневых
    файлах ``conftest.py`` устарело.

    Это важно, потому что файлы ``conftest.py`` реализуют хуки для каждого каталога,
    но когда плагин импортирован, он будет влиять на
    все дерево каталогов. Чтобы избежать путаницы, определение
    :globalvar:`pytest_plugins` в любом файле ``conftest.py``, который не находится в
    корневом каталоге тестов, является устаревшим и вызовет предупреждение.

Этот механизм упрощает совместное использование фикстур внутри приложений или даже
внешних приложений без необходимости создавать внешние плагины, используя
технику точки входа ``setuptools``.

Плагины, импортированные с помощью :globalvar:`pytest_plugins` будут также автоматически промаркированы
для переписывания assert-ов (см. :func:`pytest.register_assert_rewrite`).
Однако для того, чтобы это имело какой-либо эффект, модуль не должен быть
импортирован; если он уже был импортирован на момент обработки оператора
:globalvar:`pytest_plugins`, будет выдано предупреждение и
assertion внутри плагина не будут переписаны.  Чтобы исправить это, вы можете
либо самостоятельно вызвать :func:`pytest.register_assert_rewrite` до того, как
модуль импортируется, либо вы можете настроить код так, чтобы отложить
импортирование до тех пор, пока плагин не будет зарегистрирован.


Доступ к другому плагину по имени
----------------------------------

Если плагин хочет взаимодействовать с кодом из другого плагина, он может получить ссылку через диспетчер
плагинов следующим образом:

.. sourcecode:: python

    plugin = config.pluginmanager.get_plugin("name_of_plugin")

Если вы хотите увидеть имена существующих плагинов, используйте опцию  ``--trace-config``.


.. _registering-markers:

Регистрация пользовательских маркеров
----------------------------------------

Если ваш плагин использует какие-либо маркеры, вы должны зарегистрировать их так, чтобы они отображались в
pytest и не вызывали ложных предупреждений :ref:`cause spurious warnings <unknown-marks>`.
Например, следующий плагин зарегистрирует ``cool_marker`` и
``mark_with`` для всех пользователей:

.. code-block:: python

    def pytest_configure(config):
        config.addinivalue_line("markers", "cool_marker: this one is for cool tests.")
        config.addinivalue_line(
            "markers", "mark_with(arg, arg2): this marker takes arguments."
        )


Тестирование плагинов
--------------------------

pytest поставляется с плагином под названием ``pytester``, который помогает вам писать тесты для
вашего кода плагина. По умолчанию плагин отключен, поэтому вам придется включить его.
прежде чем вы сможете его использовать.

Вы можете сделать это, добавив следующую строку в файл ``conftest.py`` в вашем
каталог тестирования:

.. code-block:: python

    # содержимое файла conftest.py

    pytest_plugins = ["pytester"]

Также вы можете вызвать pytest с помощью опции командной строки ``-p pytester``.

Это позволит использовать фикстуру :py:class:`pytester <_pytest.pytester.Pytester>`
для тестирования вашего плагина.

Давайте продемонстрируем, что можно сделать с помощью плагина на примере. Представьте, что мы
разработали плагин, который предоставляет фикстуру ``hello``, которая yields функцию
и мы можем вызвать эту функцию с одним необязательным параметром. Она вернет
строковое значение ``Hello World!``, если мы не предоставим значение, или ``Hello {value}!``,
если мы передадим строковое значение.

.. code-block:: python

    import pytest


    def pytest_addoption(parser):
        group = parser.getgroup("helloworld")
        group.addoption(
            "--name",
            action="store",
            dest="name",
            default="World",
            help='Default "name" for hello().',
        )


    @pytest.fixture
    def hello(request):
        name = request.config.getoption("name")

        def _hello(name=None):
            if not name:
                name = request.config.getoption("name")
            return "Hello {name}!".format(name=name)

        return _hello


Теперь фикстура ``pytester`` предоставляет удобный API для создания временных
``conftest.py`` файлов и файлов тестов. Она также позволяет нам запускать тесты и
возвращать объект результата, с помощью которого мы можем подтвердить результаты тестов.

.. code-block:: python

    def test_hello(pytester):
        """Убедимся, что наш плагин работает."""

        # создаем временный файл conftest.py
        pytester.makeconftest(
            """
            import pytest

            @pytest.fixture(params=[
                "Brianna",
                "Andreas",
                "Floris",
            ])
            def name(request):
                return request.param
        """
        )

        # создаем временный тестовый файл pytest
        pytester.makepyfile(
            """
            def test_hello_default(hello):
                assert hello() == "Hello World!"

            def test_hello_name(hello, name):
                assert hello(name) == "Hello {0}!".format(name)
        """
        )

        # запускаем все тесты с помощью pytest
        result = pytester.runpytest()

        # проверяем, что все 4 теста пройдены
        result.assert_outcomes(passed=4)


Кроме того, можно скопировать примеры для папки с примерами перед запуском pytest в ней.

.. code-block:: ini

  # content of pytest.ini
  [pytest]
  pytester_example_dir = .


.. code-block:: python

    # содержимое файла test_example.py


    def test_plugin(pytester):
        pytester.copy_example("test_example.py")
        pytester.runpytest("-k", "test_example")


    def test_example():
        pass

.. code-block:: pytest

    $ pytest
    =========================== test session starts ============================
    platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-0.x.y
    cachedir: $PYTHON_PREFIX/.pytest_cache
    rootdir: $REGENDOC_TMPDIR, configfile: pytest.ini
    collected 2 items

    test_example.py ..                                                   [100%]

    ============================ 2 passed in 0.12s =============================

Для получения дополнительной информации об объекте, который возвращает ``runpytest()``, и
методах, которые он предоставляет, пожалуйста, ознакомьтесь с документацией
:py:class:`RunResult <_pytest.pytester.RunResult>`.
