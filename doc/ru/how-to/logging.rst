.. _logging:

Управление ведением логов
-------------------------------

pytest автоматически захватывает сообщения журнала уровня ``WARNING`` или выше и отображает их в
отдельном разделе для каждого упавшего теста так же, как захваченные stdout и stderr.

Запуск без опций:

.. code-block:: bash

    pytest

Упавшие тесты выглядят следующим образом:

.. code-block:: pytest

    ----------------------- Captured stdlog call ----------------------
    test_reporting.py    26 WARNING  text going to logger
    ----------------------- Captured stdout call ----------------------
    text going to stdout
    ----------------------- Captured stderr call ----------------------
    text going to stderr
    ==================== 2 failed in 0.02 seconds =====================

По умолчанию каждое записанное сообщение журнала показывает модуль, номер строки, уровень журнала и сообщение.

При желании можно указать формат журнала и даты для всего, что поддерживает модуль ведения журнала,
передав определенные параметры форматирования:

.. code-block:: bash

    pytest --log-format="%(asctime)s %(levelname)s %(message)s" \
            --log-date-format="%Y-%m-%d %H:%M:%S"

Упавшие тесты выглядят так:

.. code-block:: pytest

    ----------------------- Captured stdlog call ----------------------
    2010-04-10 14:48:44 WARNING text going to logger
    ----------------------- Captured stdout call ----------------------
    text going to stdout
    ----------------------- Captured stderr call ----------------------
    text going to stderr
    ==================== 2 failed in 0.02 seconds =====================

Эти параметры также можно настроить с помощью файла ``pytest.ini``:

.. code-block:: ini

    [pytest]
    log_format = %(asctime)s %(levelname)s %(message)s
    log_date_format = %Y-%m-%d %H:%M:%S

Кроме того, можно полностью отключить создание отчетов о захваченном контенте (stdout, stderr и журналы)
о упавших тестах с помощью:

.. code-block:: bash

    pytest --show-capture=no


Фикстура caplog
^^^^^^^^^^^^^^^^^

Внутри тестов можно изменить уровень логирования для захваченных сообщений журнала. Это поддерживается
фикстурой ``caplog``:

.. code-block:: python

    def test_foo(caplog):
        caplog.set_level(logging.INFO)
        pass

По умолчанию уровень установлен в корневом логгере, однако для удобства также можно установить
уровень журнала любого регистратора:

.. code-block:: python

    def test_foo(caplog):
        caplog.set_level(logging.CRITICAL, logger="root.baz")
        pass

Установленные уровни журнала автоматически восстанавливаются в конце теста.

Также можно использовать диспетчер контекста для временного изменения уровня лога внутри блока ``with``:

.. code-block:: python

    def test_bar(caplog):
        with caplog.at_level(logging.INFO):
            pass

Опять же, по умолчанию уровень корневого логера затрагивается, но вместо этого уровень любого
логера может быть изменен с помощью:

.. code-block:: python

    def test_bar(caplog):
        with caplog.at_level(logging.CRITICAL, logger="root.baz"):
            pass

Наконец, все журналы, отправленные логеру во время тестового запуска, становятся доступными на
устройстве в форме как экземпляров ``logging.LogRecord``, так и окончательного текста лога. Это полезно,
когда вы хотите подтвердить содержимое сообщения:

.. code-block:: python

    def test_baz(caplog):
        func_under_test()
        for record in caplog.records:
            assert record.levelname != "CRITICAL"
        assert "wally" not in caplog.text

Для всех доступных атрибутов записей журнала см. класс ``logging.LogRecord``.

Вы также можете прибегнуть к ``record_tuples``, если все, что вы хотите сделать, это убедиться,
что определенные сообщения были зарегистрированы под заданным именем регистратора с заданной
серьезностью и сообщением:

.. code-block:: python

    def test_foo(caplog):
        logging.getLogger().info("boo %s", "arg")

        assert caplog.record_tuples == [("root", logging.INFO, "boo arg")]

Можно вызвать ``caplog.clear()`` для сброса записанных журналов в тесте:

.. code-block:: python

    def test_something_with_clearing_records(caplog):
        some_method_that_creates_log_records()
        caplog.clear()
        your_test_method()
        assert ["Foo"] == [rec.message for rec in caplog.records]


Атрибут ``caplog.records`` содержит записи только с текущего этапа, поэтому внутри фазы ``настройки`` он
содержит только журналы настройки, то же самое с фазами ``call`` и ``teardown``.

Для доступа к журналам с других этапов используйте метод ``caplog.get_records(when)``. В качестве примера,
если вы хотите убедиться, что тесты, которые используют определенную фикстуру, никогда не регистрируют
никаких предупреждений, вы можете проверить записи для этапов ``setup`` и ``call`` во время teardown,
например:

.. code-block:: python

    @pytest.fixture
    def window(caplog):
        window = create_window()
        yield window
        for when in ("setup", "call"):
            messages = [
                x.message for x in caplog.get_records(when) if x.levelno == logging.WARNING
            ]
            if messages:
                pytest.fail(
                    "warning messages encountered during testing: {}".format(messages)
                )



Полный API доступен по адресу :class:`_pytest.logging.LogCaptureFixture`.


.. _live_logs:

Живые логи
^^^^^^^^^^^^

Установив для параметра конфигурации :confval:`log_cli` значение ``true``, pytest будет выводить
записи журнала по мере их отправки непосредственно в консоль.

Вы можете указать уровень ведения журнала, для которого записи журнала того же или более высокого
уровня будут выводиться на консоль, передав параметр ``--log-cli-level``. Этот параметр принимает имена
уровней ведения журнала, как показано в документации python, или целое число в качестве номера уровня
ведения журнала.

Кроме того, вы также можете указать ``--log-cli-format`` и ``--log-cli-date-format``, которые являются
зеркальными и по умолчанию используются ``--log-format`` и ``--log-date-format``, если не указан, но
применяются только к обработчику ведения журнала консоли.

Все параметры журнала CLI также можно установить в файле конфигурации INI. Названия опций:

* ``log_cli_level``
* ``log_cli_format``
* ``log_cli_date_format``

Если вам нужно записывать в файл все вызовы журналирования набора тестов, вы можете передать
``--log-file=/path/to/log/file``. Этот файл журнала открывается в режиме записи, что означает, что он
будет перезаписываться при каждом запуске сессии тестов.

Вы также можете указать уровень логирования для файла лога, передав параметр ``--log-file-level``.
Этот параметр принимает имена уровней логирования, как показано в документации Python (т. е. имена
уровней в верхнем регистре), или целое число в качестве номера уровня ведения журнала.

Кроме того, вы также можете указать ``--log-file-format`` и ``--log-file-date-format``, которые равны
``--log-format`` и ``--log-date-format``, но применяются к обработчику логирования.

Все параметры файла лога также можно установить в файле конфигурации INI. Названия опций:

* ``log_file``
* ``log_file_level``
* ``log_file_format``
* ``log_file_date_format``

Вы можете вызвать ``set_log_path()`` для динамической настройки пути лог-файла. Эта функция считается
**экспериментальной**.

.. _log_release_notes:

Примечания к выпуску
^^^^^^^^^^^^^^^^^^^^^^^^^

Эта фича была введена как замена плагина `pytest-catchlog <https://pypi.org/project/pytest-catchlog/>`_,
и они конфликтуют друг с другом. API обратной совместимости с ``pytest-capturelog`` было удалено, когда эта
фича была представлена, поэтому, если по этой причине вам все еще нужен ``pytest-catchlog``, вы можете
отключить внутреннюю фичу, добавив в свой файл ``pytest.ini``:

.. code-block:: ini

   [pytest]
       addopts=-p no:logging


.. _log_changes_3_4:

Несовместимые изменения в pytest версии 3.4
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Эта особенность была представлена в версии 3.3, а некоторые несовместимые изменения были внесены в 3.4 после
отзывов сообщества:

* Уровни логирования больше не меняются, если явно не запрошены конфигурацией :confval:`log_level` или
  параметрами командной строки ``--log-level``. Это позволяет пользователям самостоятельно настраивать объекты
  логирования. Параметр :confval:`log_level` установит уровень, который фиксируется глобально, поэтому,
  если для конкретного теста требуется более низкий уровень, чем этот, используйте функцию ``caplog.set_level()``,
  в противном случае этот тест будет подвержен ошибкам.
* :ref:`Live Logs <live_logs>` теперь отключен по умолчанию, и его можно включить, установив вариант конфигурации
  :confval:`log_cli`  в ``true``. Когда этот параметр включен, уровень детализации увеличивается,
  поэтому логирование для каждого теста можно увидеть.
* :ref:`Live Logs <live_logs>` теперь отправляется в ``sys.stdout`` и больше не требует параметр командной строки ``-s``.

Если вы хотите частично восстановить ведение журнала версии ``3.3``, вы можете добавить эти параметры
в свой файл ``ini``:

.. code-block:: ini

    [pytest]
    log_cli=true
    log_level=NOTSET

Подробнее об обсуждениях, которые привели к этим изменениям, можно прочитать в выпуске
`#3013 <https://github.com/pytest-dev/pytest/issues/3013>`_.
