.. _reference-fixtures:
.. _fixture:
.. _fixtures:
.. _`@pytest.fixture`:
.. _`pytest.fixture`:


Ссылка на фикстуры
========================================================

.. seealso:: :ref:`about-fixtures`
.. seealso:: :ref:`how-to-fixtures`


.. currentmodule:: _pytest.python

.. _`Dependency injection`: https://en.wikipedia.org/wiki/Dependency_injection


Встроенные фикстуры
--------------------

:ref:`Фикстуры <fixtures-api>` определяются с помощью декоратора :ref:`@pytest.fixture <pytest.fixture-api>`.
В Pytest есть несколько полезных встроенных фикстур:

   :fixture:`capfd`
        Захват в виде текста, вывод в файловые дескрипторы ``1`` и ``2``.

   :fixture:`capfdbinary`
        Захват в виде байтов, вывод в файловые дескрипторы ``1`` и ``2``.

   :fixture:`caplog`
        Контроль регистрации и доступа к записям журнала.

   :fixture:`capsys`
        Захват в виде текста, вывод в ``sys.stdout`` и ``sys.stderr``.

   :fixture:`capsysbinary`
        Захват в виде байтов, вывод в ``sys.stdout`` и ``sys.stderr``.

   :fixture:`cache`
        Сохранение и получение значений при запуске pytest.

   :fixture:`doctest_namespace`
        Предоставление словаря, введенного в пространство имен docstests.

   :fixture:`monkeypatch`
       Временное изменение классов, функций, словарей,
       ``os.environ``, и других объектов.

   :fixture:`pytestconfig`
        Доступ к значениям конфигурации, диспетчеру плагинов и хукам плагинов.

   :fixture:`record_property`
       Добавление дополнительных свойств к тесту.

   :fixture:`record_testsuite_property`
       Добавление дополнительных свойств в набор тестов.

   :fixture:`recwarn`
        Записывание предупреждений, выдаваемые тестовыми функциями.

   :fixture:`request`
       Предоставление информации о выполнении функции тестирования.

   :fixture:`testdir`
        Предоставляет временный тестовый каталог для помощи в запуске и
        тестирования подключаемых модулей pytest.

   :fixture:`tmp_path`
       Предоставляет объект :class:`pathlib.Path` для временной папки,
       который уникален для каждой тестовой функции.

   :fixture:`tmp_path_factory`
        Создает временные каталоги с привязкой к сеансу и возвращает объект
        :class:`pathlib.Path`.

   :fixture:`tmpdir`
        Предоставляет объект  :class:`py.path.local` для временной папки,
        который уникален для каждой тестовой функции;
        заменен на :fixture:`tmp_path`.

        .. _`py.path.local`: https://py.readthedocs.io/en/latest/path.html

   :fixture:`tmpdir_factory`
        Создает временные каталоги с привязкой к сеансу и возвращает объект
        :class:`py.path.local`;
        заменен на :fixture:`tmp_path_factory`.


.. _`conftest.py`:
.. _`conftest`:

Доступность фикстур
---------------------

Доступность фикстур определяется с точки зрения теста. Фикстура доступна для запросов тестов только
в том случае, если она находятся в области видимости, в которой определена фикстура.
Если фикстура определена внутри класса, она может быть запрошена только тестами внутри этого класса.
Но если фикстура определена в глобальной области видимости модуля, то каждый тест в этом модуле, даже
если он определен внутри класса, может запросить ее.

Аналогично, тест может быть использован фикстурой autouse, только если этот тест
находится в той же области видимости, в которой определена фикстура autouse (см.
:ref:`autouse order`).

Фикстура также может запрашивать любые другие фикстуры, независимо от того, где она определена, при условии,
что запрашивающий их тест может видеть все задействованные фикстуры.

Например: есть тестовый файл с фикстурой (``outer``), которая запрашивает фикстуру (``inner``) из области видимости,
в которой она не была определена:

.. literalinclude:: /example/fixtures/test_fixtures_request_different_scope.py

С точки зрения тестов, у них нет проблем с видимостью каждой из фикстур, от которых они зависят.

.. image:: /example/fixtures/test_fixtures_request_different_scope.svg
    :align: center

Таким образом при запуске, ``outer`` легко обнаруживает ``inner``, потому что
pytest ищет с точки зрения тестов.

.. note::
    Область видимости, в которой определена фикстура, не влияет на порядок, в котором она будет
    создана: порядок определяется логикой, описанной :ref:`здесь <fixture order>`.

``conftest.py``: совместное использование фикстур в нескольких файлах
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Файл ``conftest.py`` служит средством предоставления фикстур для всего каталога. Фикстуры, определенные
в ``conftest.py``, могут быть использованы любым тестом в этом пакете без необходимости их импортировать
(pytest автоматически обнаружит их).

Вы можете иметь несколько вложенных каталогов/пакетов, содержащих ваши тесты, и
каждая директория может иметь свой ``conftest.py`` со своими собственными фикстурами, в дополнении
к тем, которые предоставляются файлами ``conftest.py`` в родительских каталогах.

Например, при такой структуре тестовых файлов:

::

    tests/
        __init__.py

        conftest.py
            # content of tests/conftest.py
            import pytest

            @pytest.fixture
            def order():
                return []

            @pytest.fixture
            def top(order, innermost):
                order.append("top")

        test_top.py
            # content of tests/test_top.py
            import pytest

            @pytest.fixture
            def innermost(order):
                order.append("innermost top")

            def test_order(order, top):
                assert order == ["innermost top", "top"]

        subpackage/
            __init__.py

            conftest.py
                # content of tests/subpackage/conftest.py
                import pytest

                @pytest.fixture
                def mid(order):
                    order.append("mid subpackage")

            test_subpackage.py
                # content of tests/subpackage/test_subpackage.py
                import pytest

                @pytest.fixture
                def innermost(order, mid):
                    order.append("innermost subpackage")

                def test_order(order, top):
                    assert order == ["mid subpackage", "innermost subpackage", "top"]

Границы областей видимости можно визуализировать так:

.. image:: /example/fixtures/fixture_availability.svg
    :align: center

Каталоги становятся своего рода областью действия, где фикстуры, которые определены
в файле ``conftest.py`` в этой директории, становятся доступными для всей области видимости.

Тестам разрешается искать фикстуры вверх (выходя за пределы круга), но
никогда не могут спуститься вниз (шагнуть внутрь круга), чтобы продолжить поиск. Поэтому
``tests/subpackage/test_subpackage.py::test_order`` сможет найти фикстуру
``innermost``, определенную в ``tests/subpackage/test_subpackage.py``, но
та, которая определена в ``tests/test_top.py``, будет недоступна для нее, потому что
придется спуститься на уровень ниже (шагнуть внутрь круга), чтобы найти ее.

Первая фикстура, найденная тестом, и будет использоваться, таким образом
:ref:`фикстуры могут быть переопределены <override fixtures>`, если вам нужно изменить или
расширить то, что делает одна фикстура для конкретной области.

Вы также можете использовать файл ``conftest.py`` для реализации
:ref:`локальных плагинов для каждого каталога <conftest.py plugins>`.

Фикстуры из сторонних плагинов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Однако фикстуры не обязательно должны быть определены в самой структуре, чтобы они были доступны для тестов.
Они также могут быть предоставлены сторонними плагинами, которые устанавливаются, и
именно так работают многие плагины pytest. Если эти плагины установлены,
предоставляемые ими фикстуры могут быть запрошены из любой точки вашего набора тестов.

Из-за того, что они предоставляются извне структуры вашего тестового набора,
сторонние плагины не предоставляют такой области видимости, как файлы `conftest.py` и
каталоги в вашем тестовом наборе. В результате, pytest будет искать
фикстуры по шагам через диапазоны, как объяснялось ранее, достигая только
фикстур, определенных в плагинах *последними*.

Например, учитывая следующую файловую структуру:

::

    tests/
        __init__.py

        conftest.py
            # content of tests/conftest.py
            import pytest

            @pytest.fixture
            def order():
                return []

        subpackage/
            __init__.py

            conftest.py
                # content of tests/subpackage/conftest.py
                import pytest

                @pytest.fixture(autouse=True)
                def mid(order, b_fix):
                    order.append("mid subpackage")

            test_subpackage.py
                # content of tests/subpackage/test_subpackage.py
                import pytest

                @pytest.fixture
                def inner(order, mid, a_fix):
                    order.append("inner subpackage")

                def test_order(order, inner):
                    assert order == ["b_fix", "mid subpackage", "a_fix", "inner subpackage"]

Если ``plugin_a`` установлен и предоставляет фикстуру ``a_fix``, и
``plugin_b`` установлен и предоставляет фикстуру ``b_fix``, то вот как будет выглядеть
поиск фикстур в тесте:

.. image:: /example/fixtures/fixture_availability_plugins.svg
    :align: center

pytest будет искать ``a_fix`` и ``b_fix`` в плагинах только после
первоначального поиска их внутри ``tests/``.

.. note:

    pytest может сообщить вам, какие фикстуры доступны для данного теста, если вы вызовете команду
    ``pytests`` вместе с именем теста (или областью видимости, в которой он находится), и указать флаг
    флаг ``--fixtures``, например, ``pytest --fixtures test_something.py``.
    (фикстуры с именами, начинающимися с ``_``, будут показаны, только если вы также укажете
    флаг ``-v``).


.. _`fixture order`:

Порядок создания экземпляров фикстур
----------------------------------------------

Перед выполнением теста, pytest узнает какие фикстуры и в каком порядке будут выполняться.
Для определения порядка выполнения pytest учитывает 3 фактора:

1. область действия(scope)
2. зависимости
3. autouse

Имена фикстур или тестов, в которых они определены, порядок, в котором они определены, и порядок, в
котором запрашиваются фикстуры, не имеют никакого отношения к порядку выполнения вне зависимости от
совпадения. Хотя pytest будет стараться, чтобы такие совпадения оставались неизменными от запуска к
запуску, на это не стоит полагаться. Если вы хотите контролировать порядок выполнения, безопаснее
всего полагаться на эти три вещи и убедиться, что зависимости точно установлены.

В первую очередь выполняются фикстуры с более высокой областью видимости
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Внутри функционального запроса на фикстуры, фикстуры более высокого уровня (такие как
``session``) выполняются раньше, чем фикстуры более низкого уровня (например, ``function`` или
``class``).

Вот пример:

.. literalinclude:: /example/fixtures/test_fixtures_order_scope.py

Тест будет пройден, потому что первыми выполняются фикстуры с большей областью видимости.

Порядок сводится к этому:

.. image:: /example/fixtures/test_fixtures_order_scope.svg
    :align: center

Фикстуры одного порядка выполняются на основе зависимостей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Когда одна фикстура запрашивает вторую фикстуру, то сначала выполняется вторая фикстура.
Таким образом, если фикстура ``a`` запрашивает фикстуру ``b``, фикстура ``b`` будет выполнена первой,
потому что ``a`` зависит от ``b`` и не может работать без нее. Даже если ``a``
не нужен результат ``b``, она все равно может запросить ``b``, если ей нужно убедиться в том,
что она будет выполнена после ``b``.

Например:

.. literalinclude:: /example/fixtures/test_fixtures_order_dependencies.py

Если мы нарисуем, что от чего зависит, мы получим что-то вроде этого:

.. image:: /example/fixtures/test_fixtures_order_dependencies.svg
    :align: center

Правила, предоставляемые каждой фикстурой(относительно того, как каждая фикстура(фикстуры)
должна использовать друг друга) достаточно подробны, чтобы их можно было свести к следующему:

.. image:: /example/fixtures/test_fixtures_order_dependencies_flat.svg
    :align: center

Через эти запросы должно быть предоставлено достаточно информации для того, чтобы pytest
смог определить четкую, линейную цепочку зависимостей и, как результат,
порядок действий для данного теста. Если существует какая-либо двусмысленность, и порядок
операций может быть интерпретирован более чем одним способом, вы должны предположить, что pytest
может выбрать любую из этих интерпретаций в любой момент.

Например, если ``d`` не запрашивает ``c``, т.е. график будет выглядеть так:

.. image:: /example/fixtures/test_fixtures_order_dependencies_unclear.svg
    :align: center

Так как никто не запрашивал ``c``, кроме ``g``, а ``g`` также запрашивает ``f``,
и теперь не ясно, должна ли ``c`` идти до/после ``f``, ``e`` или ``d``. Единственные правила, которые
были установлены для ``c``, это то, что она должна выполняться после ``b`` и до ``g``.

pytest не знает, куда в данном случае следует поместить ``c``, поэтому следует предположить,
что она может находиться в любом месте между ``g`` и ``b``.

Это не обязательно плохо, но об этом следует помнить. Если порядок
их выполнения может повлиять на поведение, на которое нацелен тест, или может
иначе повлиять на результат теста, то порядок должен быть определен
явно таким образом, чтобы pytest мог линеаризовать/"выравнивать" этот порядок.

.. _`autouse order`:

Фикстуры autouse выполняются первыми в пределах их области
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Предполагается, что фикстуры autouse применяются к каждому тесту, который может на них ссылаться,
поэтому они выполняются перед другими фикстурами в этой области видимости. Фикстуры, которые
запрашиваются фикстурами autouse, фактически сами становятся autouse фикстурами для тестов,
к которым применяется реальная autouse фикстура.

Итак, если фикстура ``a`` является autouse, а фикстура ``b`` не является, но фикстура ``a``
запрашивает фикстуру ``b``, то фикстура ``b`` фактически будет фикстурой autouse
но только для тех тестов, к которым применяется ``a``.

В последнем примере граф стал неясным, если ``d`` не запросила ``c``. Но
если бы ``c`` был autouse, то ``b`` и ``a`` также были бы autouse,
потому что ``c`` зависит от них. В результате, все они будут смещены выше
не-autouse элементов в этой области видимости.

Итак, если тестовый файл выглядел так:

.. literalinclude:: /example/fixtures/test_fixtures_order_autouse.py

граф будет выглядеть так:

.. image:: /example/fixtures/test_fixtures_order_autouse.svg
    :align: center

Поскольку ``c`` теперь можно поместить выше ``d`` на графе, pytest может снова
линеаризовать граф в соответствии с этим:

В этом примере ``c`` также делает ``b`` и ``a`` эффективными autouse фикстурами.

Однако будьте осторожны с autouse, так как фикстуры autouse будут автоматически
выполняться для каждого теста, который может его достичь, даже если они не запрашивают его.
Например, рассмотрим этот файл:

.. literalinclude:: /example/fixtures/test_fixtures_order_autouse_multiple_scopes.py

Даже если ничто в ``TestClassWithC1Request`` не запрашивает ``c1``, она все равно
выполняется для тестов внутри него:

.. image:: /example/fixtures/test_fixtures_order_autouse_multiple_scopes.svg
    :align: center

Но только потому, что одна фикстура autouse запросила фикстуру не-autouse, это
не означает, что не-autouse фикстура становится autouse фикстурой для всех контекстов
к которым она может применяться. Фактически она становится фикстурой auotuse только в тех контекстах,
к которым может применяться настоящая фикстура auotuse(та, которая запросила фикстуру без auotuse).

Например, взгляните на этот тестовый файл:

.. literalinclude:: /example/fixtures/test_fixtures_order_autouse_temp_effects.py

Это будет выглядеть примерно так:

.. image:: /example/fixtures/test_fixtures_order_autouse_temp_effects.svg
    :align: center

Для ``test_req`` и ``test_no_req`` внутри ``TestClassWithAutouse``, ``c3`` фактически делает ``c2``
autouse фикстурой, поэтому ``c2`` и ``c3`` выполняются для обоих тестов, несмотря на то, что не
запрашивается, и почему ``c2`` и ``c3`` выполняются перед ``c1`` для ``test_req``.

Если это сделало ``c2`` *фактически* фикстурой autouse, то ``c2`` также будет выполняться для тестов
внутри ``TestClassWithoutAutouse``, поскольку они могут ссылаться на ``c2``, если захотят. Но это не так,
потому что с точки зрения тестов ``TestClassWithoutAutouse``, ``c2`` не является фикстурой autouse,
поскольку они не могут видеть ``c3``.


.. note:

    pytest может сказать вам, в каком порядке фикстуры будут выполняться для данного теста, если вы
    вызовете ``pytests`` вместе с именем теста (или его областью) и предоставите флаг ``--setup-plan``,
    например ``pytest --setup-plan test_something.py``(фикстуры с именами, начинающимися с ``_``, будут
    показаны, только если вы также укажете флаг ``-v``).
