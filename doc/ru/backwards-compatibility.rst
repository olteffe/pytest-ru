.. _backwards-compatibility:

Политика обратной совместимости
=================================

.. versionadded: 6.0

pytest активно развивается и представляет собой проект, который создавался десятилетиями, мы продолжаем узнавать о
новых и лучших структурах для выражения различных деталей тестирования.

Пока мы внедряем эти изменения, мы стараемся обеспечить легкий переход и не хотим вызывать ненужный отток
наших пользователей и авторов плагинов сообщества.

На данный момент pytest рассматривает несколько типов переходов обратной совместимости:

a) тривиальный: API, которые тривиально переводятся на новую механику,
   и не вызывают проблемных изменений.

   Мы стараемся поддерживать их на неопределенный срок, одновременно поощряя пользователей переходить на
   более новые механики с помощью документации.

b) переходный: старый и новый API не противоречат друг другу
   и мы можем помочь пользователям перейти на новый API, используя предупреждения, при этом поддерживая оба API в течение длительного времени.

   Мы начинаем удаление устаревшей функциональности только в основных релизах (например, если мы изменили что-то в 3.0, мы начнем удалять это в 4.0), и сохраним ее по крайней мере в двух второстепенных релизах (например, если мы изменили что-то в 3.9, а 4.0 - следующий релиз, мы начнем удалять ее в 5.0, а не в 4.0).

   Когда срок устаревания истечет(например, выйдет 4.0), мы не будем удалять устаревшую функциональность сразу, а воспользуемся стандартными фильтрами предупреждений, чтобы превратить их в **ошибки** по умолчанию. Такой подход дает понять, что удаление неизбежно, и при этом дает вам время превратить устаревшую функцию в предупреждение, а не в ошибку, чтобы вы могли разобраться с ней в свое время. В следующем минорном выпуске (например, 4.1) функция будет фактически удалена.


c) серьезное изменение: должно рассматриваться только в тех случаях, когда обычный переход неоправданно неустойчив и может отсрочить важные разработки/функции на годы.
   Кроме того, должны быть ограничены API, где число реальных пользователей очень мало (например, затрагивая только некоторые плагины), и могут быть заранее согласованы с сообществом.

    Примеры таких предстоящих изменений:

   * удаление ``pytest_runtest_protocol/nextitem`` - `#895`_
   * перестановка дерева узлов для включения ``FunctionDefinition``
   * перестановка ``SetupState`` `#895`_

   Серьезные изменения должны быть объявлены первыми в выпуске, содержащем:

   * Подробное описание изменения
   * Логическое обоснование
   * Ожидаемое влияние на пользователей и авторов плагинов (пример в `#895`_)

   Если по вопросу нет твердых *-1*, за ним должен последовать первоначальный Pull Request для проверки
   концепции.

   Этот POC служит как точка координации для оценки воздействия, так и потенциальным стимулом для
   того, чтобы все-таки придумать переходное решение.

   По прошествии разумного количества времени PR может быть объединен для создания нового основного релиза.

   Чтобы PR прошел путь от POC до принятия, он должен содержать:
   * Настройку ошибок/предупреждений о возражениях, которые помогают пользователям исправлять и переносить свой код.
     Если есть возможность ввести период возражения в рамках текущей серии, до настоящего изменения, он должен быть
     представлен в отдельном PR и быть частью текущего потока релизов.
   * Подробное описание обоснования и примеры переноса кода в ``doc/en/deprecations.rst``.


История
=========


Сосредоточьтесь на плавном переходе - stance (для 6.0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Поддержание обратной совместимости имеет очень высокий приоритет в проекте pytest. Несмотря на то, что за
прошедшие годы функциональность была упразднена, большая ее часть все еще поддерживается. Все удаления в
pytest были сделаны потому, что появились более простые или более эффективные способы выполнения тех же
задач, делая старый способ выполнения ненужным.

С выходом pytest 3.0 мы ввели четкую схему коммуникации о том, когда мы действительно уберем старый
"косяк" и вежливо попросим вас использовать вместо него новый, при этом давая вам достаточно времени,
чтобы скорректировать ваши тесты или выразить озабоченность, если есть веские причины для сохранения
устаревшей функциональности.

Чтобы сообщить об изменениях, мы выпускаем предупреждения об устаревании, используя собственную иерархию
предупреждений (см. :ref:`internal-warnings`). Эти предупреждения могут быть подавлены стандартными
средствами: флагом командной строки ``-W`` или опциями ini ``filterwarnings`` (см. :ref:`warnings`),
но мы рекомендуем использовать их редко и временно, а по возможности прислушиваться к предупреждениям.

Мы начнем удаление устаревшей функциональности только в основных релизах (например, если мы удалили
что-то в 3.0, мы начнем удалять это в 4.0), и сохраним ее по крайней мере в двух второстепенных релизах
(например, если мы удалили что-то в 3.9, а 4.0 - следующий релиз, мы начнем удалять это в 5.0, а не в 4.0).

Когда срок устаревания истечет(например, выйдет 4.0), мы не будем удалять устаревшую функциональность
сразу, а воспользуемся стандартными фильтрами предупреждений, чтобы превратить их в **ошибки** по умолчанию.
Такой подход дает понять, что удаление неизбежно, и при этом дает вам время превратить устаревшую
функцию в предупреждение, а не в ошибку, чтобы вы могли разобраться с ней в свое время. В следующем
минорном выпуске (например, 4.1) функция будет фактически удалена.


Дорожная карта устаревания
----------------------------

Функции, которые в настоящее время не рекомендуются и были удалены в предыдущих выпусках, можно найти в :ref:`deprecations`.

Мы отслеживаем прекращение поддержки и удаление функций в будущем, используя контрольные точки и метки
`deprecation <https://github.com/pytest-dev/pytest/issues?q=label%3A%22type%3A+deprecation%22>`_ и
`removal <https://github.com/pytest-dev/pytest/labels/type%3A%20removal>`_ в GitHub.


.. _`#895`: https://github.com/pytest-dev/pytest/issues/895
