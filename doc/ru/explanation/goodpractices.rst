.. highlight:: python
.. _`goodpractices`:

Хорошие практики по интеграции
=================================================

Установка пакета с помощью ``pip``
-------------------------------------------------

При разработке рекомендуется использовать venv_ для создания виртуального окружения и
pip_ для установки вашего приложения и любых зависимых пакетов,
также как и самого ``pytest``.
Это гарантирует, что ваш код и зависимости изолированы от вашей системной установки Python.

Затем поместите файл ``setup.py`` в корень вашего проекта со следующим минимальным содержимым:

.. code-block:: python

    from setuptools import setup, find_packages

    setup(name="PACKAGENAME", packages=find_packages())

Где ``PACKAGENAME`` - это имя вашего пакета. Затем вы можете установить ваш пакет в режиме редактирования,
запустив в той же директории:

.. code-block:: bash

     pip install -e .

Что позволит вам менять код исходных файлов(как тестов, так и самого приложения) и перезапускать тесты
по вашему желанию. Это аналогично запуску ``python setup.py develop`` или ``conda develop`` и
устанавливаете ваш пакет, используя символьную ссылку на разрабатываемый код.

.. _`test discovery`:
.. _`Python test discovery`:

Соглашения для обнаружения тестов ``Python``
-------------------------------------------------

В ``pytest`` реализовано следующее стандартное обнаружение тестов:

* Если аргументы не указаны, сбор начинается с :confval:`testpaths`
  (если настроено) или с текущего каталога. Кроме того, аргументы командной строки можно
  использовать с любой комбинацией каталогов, имен файлов или идентификаторов узлов.
* Рекурсивный поиск в каталогах, если они не совпадают с :confval:`norecursedirs`.
* В этих каталогах ищутся файлы ``test_*.py`` или ``*_test.py``, импортированные по `test package name`_.
* Из этих файлов собираются тестовые задания:

  * функции и методы с префиксом ``test``, расположенные вне классов
  * тестовые функции и методы с префиксом ``test`` внутри классов с префиксом "Test" (без метода "__init__")

Примеры того, как настроить ваше обнаружение тестов: :doc:`/example/pythoncollection`.

В модулях ``Python`` ``pytest`` также обнаруживает тесты, используя стандартные метод подкласса
:ref:`unittest.TestCase <unittest.TestCase>`.


Выбор шаблона размещения и правила импорта тестов
--------------------------------------------------

``pytest`` поддерживает два способа размещения тестов:

Тесты вне кода приложения
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Размещение тестов в отдельном каталоге вне фактического кода приложения может быть полезно,
если у вас много функциональных тестов или же по каким-то причинам вы хотите держать
тесты отдельно от фактического кода приложения (зачастую это хорошая идея):

.. code-block:: text

    setup.py
    mypkg/
        __init__.py
        app.py
        view.py
    tests/
        test_app.py
        test_view.py
        ...

Это дает следующие преимущества:

* Ваши тесты могут работать с установленной версией после выполнения команды ``pip install .``.
* Вы можете тестировать локальную копию приложения в режиме редактирования после выполнения
  ``pip install --editable .``.
* Если у вас нет ``setup.py``-файла и вы пользуетесь тем, что ``Python``
  по умолчанию помещает текущий каталог в ``sys.path`` для импорта вашего пакета,
  вы можете выполнить ``python -m pytest``, чтобы запустить тестирование локальной копии напрямую,
  без использования ``pip``.

.. note::

    См. :ref:`pytest vs python -m pytest` чтобы узнать больше о разнице между вызовом ``pytest``
    и ``python -m pytest``.

Обратите внимание, что эта схема имеет недостаток, если вы используете режим импорта ``prepend``
:ref:`import mode <import-modes>` (по умолчанию): ваши тестовые файлы должны иметь **уникальные имена**,
потому что ``pytest`` будет импортировать их как модули *верхнего уровня*, поскольку нет пакетов,
из которых можно было бы получить полное имя пакета. Другими словами, тестовые файлы в приведенном
выше примере будут импортированы как модули верхнего уровня ``test_app`` и ``test_view`` путем добавления
``tests/`` в ``sys.path``.

Если нужны тестовые модули с тем же именем, вы можете добавить файлы ``__init__.py`` в вашу папку ``tests``
и ее подпапки, заменив их на пакеты:

.. code-block:: text

    setup.py
    mypkg/
        ...
    tests/
        __init__.py
        foo/
            __init__.py
            test_view.py
        bar/
            __init__.py
            test_view.py

В этом случае ``pytest`` позволяет использовать одинаковые имена для файлов, поскольку на самом деле
будут запускаться файлы с именами ``tests.foo.test_view`` и ``tests.bar.test_view``. Но теперь появляется
тонкость: чтобы загрузить тестовые модули из каталога ``tests``, ``pytest`` добавляет корень репозитория
к переменной ``sys.path``, что добавляет побочный эффект, при котором ``mypkg`` также импортируется.

Могут возникнуть проблемы, если используется такой инструмент, как `tox`_, для тестирования вашего пакета в
виртуальной среде, потому что вы хотите протестировать *установленную* версию вашего пакета, а не
локальный код из репозитория.

.. _`src-layout`:

В этой ситуации **настоятельно** рекомендуется использовать шаблон ``src``, в котором корневой пакет
приложения находится в подкаталоге вашего корневого каталога:

.. code-block:: text

    setup.py
    src/
        mypkg/
            __init__.py
            app.py
            view.py
    tests/
        __init__.py
        foo/
            __init__.py
            test_view.py
        bar/
            __init__.py
            test_view.py

Этот шаблон предотвращает множество распространенных ошибок и имеет много преимуществ, которые лучше
разъяснены в этом блоге:
`blog post by Ionel Cristian Mărieș <https://blog.ionelmc.ro/2014/05/25/python-packaging/#the-structure>`_.

.. note::
    Новый аргумент ``--import-mode=importlib`` (см. :ref:`import-modes`) не имеет ни одного из
    перечисленных выше недостатков, потому что ``sys.path`` не изменяется при импорте тестовых модулей,
    поэтому пользователям, столкнувшимся с этой проблемой, настоятельно рекомендуется попробовать его
    и сообщить, подходит ли им новый вариант.

    Однако настоятельно рекомендуется использовать шаблон каталогов с ``src``.

Тесты как часть кода приложения
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Встраивание каталогов тестов в пакет приложения полезно, если у вас есть прямая связь между тестами
и модулями приложения и вы хотите распространять их вместе с вашим приложением:

.. code-block:: text

    setup.py
    mypkg/
        __init__.py
        app.py
        view.py
        test/
            __init__.py
            test_app.py
            test_view.py
            ...

В этом случае проще всего запустить тесты, используя опцию ``--pyargs``:

.. code-block:: bash

    pytest --pyargs mypkg

``pytest`` найдет, где установлен ``mypkg`` и соберет оттуда тесты.

Обратите внимание, что такой способ также работает с шаблоном ``src``, упомянутом в предыдущем разделе.


.. note::

    Вы можете использовать пространство имен Python3 (PEP420) для своего приложения,
    но ``pytest`` все равно будет искать :ref:`имя для импорта <test package name>`,
    основываясь на наличии файлов "__init__.py". Если вы используете один из рекомендуемых
    способов формирования структуры файловой системы, но не хотите использовать файлы ``__init__.py``
    в ваших директориях, эта схема будет работать на версиях ``Python3.3`` и выше.
    Однако при "встроенных" тестах вам придется использовать абсолютный импорт, чтобы добраться до
    кода вашего приложения.

.. _`test package name`:

.. note::

    В режимах импорта ``prepend`` и ``append``, если при рекурсивном поиске по файловой системе ``pytest``
    находит тестовые файлы вида  ``"a/b/test_module.py"``, то определяется имя импорта следующим образом:

    * определяется базовый каталог ``basedir``: это первый, самый "высший" (к корню) каталог, не содержащий
      ``__init__.py``.  Если, например, оба ``a`` и ``b`` содержат файлы ``__init__.py``
      тогда ``a`` становится ``basedir``.

    * выполняется ``sys.path.insert(0, basedir)``, чтобы сделать тестовый модуль импортируемым под
      полным именем импорта.

    * выполняется ``import a.b.test_module``, где путь определяется преобразованием разделителей
      ``/`` в символы ``.``. Это означает, что нужно сопоставлять имена файлов и каталогов
      импортируемым именам напрямую.

    Причина такого изменения метода импорта заключается в том,
    что в крупных проектах тестовые модули могут импортировать друг друга,
    и получение канонического имени импорта помогает избежать сюрпризов
    (например, двойного импорта тестового модуля).

    С параметром ``--import-mode=importlib`` все становится менее запутанным, потому что ``pytest`` не
    требует изменения ``sys.path`` или ``sys.modules``, что делает ситуацию более ясной.


.. _`virtualenv`: https://pypi.org/project/virtualenv/
.. _`buildout`: http://www.buildout.org/
.. _pip: https://pypi.org/project/pip/

.. _`use tox`:

tox
------

Если работа выполнена и вы хотите убедиться, что готовый пакет проходит
все тесты, можно обратить внимание на  `tox`_ - инструмент автоматизации тестирования
и его `поддержку pytest <https://tox.readthedocs.io/en/latest/example/pytest.html>`_.
``tox`` помогает настроить виртуальное окружение с заранее заданными
зависимостями и затем запускать предварительно настроенную команду тестирования
с различными опциями. ``tox`` тестирует установленный пакет, а не источник кода,
тем самым помогая найти погрешности сборки.

.. _`venv`: https://docs.python.org/3/library/venv.html
