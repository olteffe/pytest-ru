.. _about-fixtures:

О фикстурах
===============

.. seealso:: :ref:`how-to-fixtures`
.. seealso:: :ref:`Fixtures reference <reference-fixtures>`

Фикстуры в pytest спроектированы так, чтобы быть подробными, модульными и масштабируемыми.

Что такое фикстуры
------------------------

Фмкстуры `fixture <https://en.wikipedia.org/wiki/Test_fixture#Software>`_ в тестировании
обеспечивают надежность, согласованность и повторяемость результатов в тестах.
Фикстура может настраивать окружение (например, базу данных, настроенную с известными
параметрами) или содержимое (например, набор данных).

Фикстуры определяют этапы и данные, составляющие этап **настройки** теста
(см .: :ref:`test-anatomy`). В pytest это функции, которые вы определяете для
этой цели. Их также можно использовать для определения этапа **действие**;
это мощный метод разработки более сложных тестов.

Доступ к службам, состоянию или другим рабочим окружениям, установленным фикстурами,
осуществляется тестовыми функциями через аргументы. Для каждой фикстуры,
используемой тестовой функцией, обычно есть параметр (названный в честь фикстуры)
в определении тестовой функции.

Можно сказать pytest, что конкретная функция - это фикстура, декорируя ее с помощью
:py:func:`@pytest.fixture <pytest.fixture>`. Вот простой пример, как может выглядеть
фикстура в pytest:

.. code-block:: python

    import pytest


    class Fruit:
        def __init__(self, name):
            self.name = name

        def __eq__(self, other):
            return self.name == other.name


    @pytest.fixture
    def my_fruit():
        return Fruit("apple")


    @pytest.fixture
    def fruit_basket(my_fruit):
        return [Fruit("banana"), my_fruit]


    def test_my_fruit_in_basket(my_fruit, fruit_basket):
        assert my_fruit in fruit_basket

Также не обязательно ограничиваться одной фикстурой. Можно использовать столько фикстур,
сколько захотите, а также одни фикстуры могут использоваться другими. Вот где преимущество
фикстур pytest.

Улучшения по сравнению с функциями setup/teardown в стиле xUnit
----------------------------------------------------------------

Фикстуры pytest значительно удобнее по сравнению с классическим xUnit-стилем
setup/teardown функций:

* фикстуры имеют явные имена и активируются путем их объявления
  в тестовых функциях, модулях, классах или всего проекта.

* фикстуры выполнены по модульному принципу, поскольку каждый вызов фикстуры инициализирует
  *функцию-фикстуру*, которая в свою очередь может использовать другие фикстуры.

* управление фикстурами расширяется от простого модуля до комплексного функционального тестирования,
  позволяя параметризовать фикстуры и тесты в соответствии с конфигурацией и опциями компонентов,
  или повторно использовать фикстуры внутри функции, класса, модуля или тестовой сессии в целом.

* Логикой teardown можно легко и безопасно управлять независимо от того, сколько фикстур
  используется, без необходимости тщательно обрабатывать ошибки вручную или контролировать
  порядок добавления этапов **очистки**.

Кроме того, pytest продолжает поддерживать :ref:`xunitsetup`.  Вы можете использовать оба
стиля, постепенно переходя от классического к новому по своему усмотрению.
Можно начинать с существующего :ref:`unittest.TestCase style <unittest.TestCase>` или
с :ref:`nose based <nosestyle>` проектов.

Ошибки фикстур
----------------

pytest делает все возможное, чтобы разместить все фикстуры для данного теста в
линейном порядке, чтобы было видно, какая фикстура происходит первой, второй,
третьей и т. д. Однако, если в вышестоящей фикстуре есть ошибка и вызывается
исключение, pytest прекратит выполнение фикстуры для этого теста и пометит тест ошибкой.

Когда тест помечен как ошибочный, то это не означает, что тест не прошел.
Это просто означает, что тест даже не может быть начат, потому что одна из зависимостей
имеет проблему.

Это одна из причин, по которой рекомендуется сокращать ненужные зависимости для
данного теста.
Таким образом, проблема в чем-то не имеющем отношение не отвлекает дополнительной и
частичной информацией того, в чем может быть или не быть проблема.

Вот короткий пример, который поможет разъяснить:

.. code-block:: python

    import pytest


    @pytest.fixture
    def order():
        return []


    @pytest.fixture
    def append_first(order):
        order.append(1)


    @pytest.fixture
    def append_second(order, append_first):
        order.extend([2])


    @pytest.fixture(autouse=True)
    def append_third(order, append_second):
        order += [3]


    def test_order(order):
        assert order == [1, 2, 3]


Если по какой-то причине в ``order.append(1)`` была ошибка и это вызывает исключение,
мы не сможем узнать, если с ``order.extend([2])`` или с ``order += [3]`` также будут проблемы.
После того, как ``append_first`` генерирует исключение, pytest больше не будет запускать
фикстуры для ``test_order`` и даже не будет пытаться запустить сам ``test_order``.
Единственное, что могло бы быть выполнено, - это ``order`` и ``append_first``.


Совместное использование тестовых данных
-------------------------------------------

Если вы хотите сделать тестовые данные из файлов доступными для ваших тестов,
хороший способ сделать это - загрузить эти данные в фикстуру для использования
вашими тестами. При этом используются механизмы автоматического кэширования pytest.

Еще один хороший способ - добавить файлы данных в папку ``tests``.
Существуют также плагины сообщества, которые помогают управлять этим аспектом
тестирования, например `pytest-datadir <https://pypi.org/project/pytest-datadir/>`__
и `pytest-datafiles <https://pypi.org/project/pytest-datafiles/>`__.
