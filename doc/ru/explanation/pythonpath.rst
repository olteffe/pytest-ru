.. _pythonpath:

механизмы импорта pytest и ``sys.path``/``PYTHONPATH``
========================================================

.. _`import-modes`:

Режимы импорта
---------------

``pytest`` как тестовому фреймворку необходимо импортировать тестовые модули и
файлы ``conftest.py`` для выполнения.

Импорт файлов в Python (по крайней мере, до недавнего времени) - нетривиальный процесс, часто требующий
изменения `sys.path <https: docs.python.org3librarysys.htmlsys.path>`__. Некоторыми аспектами процесса
импорта можно управлять с помощью флага командной строки ``--import-mode``, который может принимать следующие
значения:

* ``prepend`` (по умолчанию): путь к каталогу, содержащий каждый модуль, будет вставлен в
  начало: :py:data:`sys.path`, если его еще нет, а затем импортирован с помощью встроенного
  `__import__ <https://docs.python.org/3/library/functions.html#__import__>`__.

  Для этого требуется, чтобы имена тестовых модулей были уникальными, когда дерево тестовых каталогов не
  организовано по пакетам, потому что модули будут помещены в :py:data:`sys.modules` после импорта.

  Это классический механизм, появившийся еще со времен поддержки Python 2.

* ``append``: каталог, содержащий каждый модуль, добавляется в конец :py:data:`sys.path`, если
  его еще нет, и импортируется с помощью` `__import__``.

  Это позволяет запускать тестовые модули для установленных версий пакета, даже если тестируемый
  пакет имеет тот же корень импорта. Например:

  ::

        testing/__init__.py
        testing/test_pkg_under_test.py
        pkg_under_test/

  тесты будут запускаться с установленной версией ``pkg_under_test`` при использовании ``--import-mode=append``,
  тогда как с ``prepend`` они выберут локальную версию. Такая путаница является причиной того, почему
  мы выступаем за использование шаблонов :ref:`src <src-layout>`.

  Так же как и при ``prepend``, требуется, чтобы имена тестовых модулей были уникальными, когда дерево
  тестовых каталогов не организовано по пакетам, потому что модули будут помещены в
  :py:data:`sys.modules` после импорта.

* ``importlib``: новое в pytest-6.0, этот режим использует `importlib <https://docs.python.org/3/library/importlib.html>`__
  для импорта тестовых модулей. Это дает полный контроль над процессом импорта и не требует изменения
  :py:data:`sys.path`.

  Поэтому не требуется, чтобы имена тестовых модулей были уникальными, но при этом
  тестовые модули становятся не импортируемыми друг другом.

  Мы намерены сделать ``importlib`` по умолчанию в будущих выпусках, в зависимости от отзывов.

сценарии режимов импорта ``prepend`` и ``append``
---------------------------------------------------

Вот список сценариев при использовании режимов импорта ``prepend`` или ``append``, в которых
необходимо изменить ``sys.path``, чтобы импортировать тестовые модули или файлы ``conftest.py``, а также
проблемы, с которыми пользователи могут столкнуться из-за этого.

Тестовые модули / ``conftest.py`` файлы внутри пакетов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Рассмотрим этот шаблон файлов и каталогов::

    root/
    |- foo/
       |- __init__.py
       |- conftest.py
       |- bar/
          |- __init__.py
          |- tests/
             |- __init__.py
             |- test_foo.py


При выполнении:

.. code-block:: bash

    pytest root/

``pytest`` обнаружит ``foo/bar/tests/test_foo.py`` и поймет, что это часть пакета, учитывая, что в той же папке
есть файл ``__init__.py``. Затем будет проведен поиск снизу вверх, пока не найдется последняя папка, которая все еще
содержит файл ``__init__.py``, чтобы найти *корень* пакета (в данном случае ``foo/``). Чтобы загрузить
модуль, ``pytest`` вставит ``root/`` в начало ``sys.path`` (если его еще нет), чтобы загрузить ``test_foo.py`` в качестве
*модуля* ``foo.bar.tests.test_foo``.

Та же логика применяется к файлу ``conftest.py``: он будет импортирован как модуль ``foo.conftest``.

Сохранение полного имени пакета важно, когда тесты находятся в пакете, чтобы избежать проблем и
позволить тестовым модулям иметь повторяющиеся имена. Это также подробно обсуждается в
:ref:`test discovery`.

Изолированные тестовые модули / файлы ``conftest.py``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Рассмотрим этот макет файла и каталога::

    root/
    |- foo/
       |- conftest.py
       |- bar/
          |- tests/
             |- test_foo.py


При выполнении:

.. code-block:: bash

    pytest root/

``pytest`` обнаружит ``foo/bar/tests/test_foo.py`` и поймет, что он НЕ является частью пакета, учитывая, что в той
же папке нет файла ``__init__.py``. Затем будет добавлен ``root/foo/bar/tests`` в ``sys.path``, чтобы импортировать
``test_foo.py`` в качестве *модуля* ``test_foo``. То же самое можно сделать с файлом ``conftest.py``, добавив
``root/foo`` в ``sys.path``, чтобы импортировать его как ``conftest``.

По этой причине в этом шаблоне не может быть тестовых модулей с одинаковыми именами, поскольку
все они будут импортированы в глобальное пространство имен импорта.

Это также подробно обсуждается в :ref:`test discovery`.

.. _`pytest vs python -m pytest`:

Вызов ``pytest`` или ``python -m pytest``
-----------------------------------------------

Запуск ``pytest`` с ``pytest [...]`` вместо ``python -m pytest [...]`` почти эквивалентно,
за исключением того, что последний добавит текущий каталог в ``sys.path`` , что является стандартным
поведением ``python``.


Смотрите также :ref:`invoke-python`.
